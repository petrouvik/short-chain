# Emulator

The **emulator** simulates the execution of object code generated by the assembler and linker.
It models the processor’s registers, memory, and I/O devices, and runs instructions exactly as the target machine would.

---

## Overview

The emulator:

* Loads a binary file produced by the linker.
* Simulates a CPU with:

  * 16 **general-purpose registers** (`r0`–`r15`)
  * Several **control and status registers** (`STATUS`, `CAUSE`, `HANDLER`, etc.)
* Maintains a **memory map** of 32-bit words.
* Handles **interrupts**, **I/O**, and **timing** through concurrent threads.
* Prints the final CPU state upon normal termination or error.

Execution starts from a predefined **program counter (PC)** value, and proceeds instruction by instruction until a `halt` instruction is executed or a fatal error occurs.

---

## File Loading

Before execution, the emulator reads the linked binary file.
Each entry in the file specifies:

* A **4-byte memory address**
* A **1-byte value**

Values are written into memory at their respective addresses.
Duplicate address entries in the file are treated as an input error.

---

## Execution Cycle

The main loop of the emulator repeatedly:

1. **Fetches** the next instruction from memory.
2. **Decodes** the opcode, mode, and operand fields.
3. **Executes** the instruction.
4. **Handles interrupts** (if pending).

When execution stops normally (after a `halt` instruction), the emulator prints the state of all registers.

---

## Interrupts

The emulator supports several types of interrupts:

* **Illegal instruction**
* **Software interrupt**
* **Timer interrupt**
* **Terminal interrupt**

Interrupts can be **masked** globally or individually through bits in the `STATUS` register.

When an interrupt occurs:

1. The current `STATUS` and `PC` are **pushed onto the stack**.
2. The cause code is written to `CAUSE`.
3. Interrupts are masked.
4. The `PC` is set to the value in the `HANDLER` register.

The handler routine executes and, upon return, restores the previous state to continue execution.

---

## Timer

The timer runs in a separate thread and begins once the processor writes to the **timer configuration register** at address `0xFFFFFF10`.

The configuration value (`tim_cfg`) determines the interrupt frequency, with predefined delays ranging from **500 ms** to **60 s**.

When the timer expires:

* The **timer interrupt flag** is set.
* The CPU processes the timer interrupt if it is not masked.

This allows programs to perform periodic actions, such as refreshing the display or polling input.

---

## Terminal

The terminal emulates a simple character device and runs concurrently in its own thread.
It provides:

* **Input:** Reading a single byte from standard input (non-blocking).
  When a key is pressed, the character is written to the **terminal input register** and a **terminal interrupt** is triggered.
* **Output:** When the CPU writes to the **terminal output register**, the character is printed to standard output.
  The CPU must wait until the terminal becomes ready before writing again.

The terminal uses non-canonical mode (no buffering or echo) to allow immediate character input and output.

---

## Memory Map

Certain memory addresses are reserved for device-mapped I/O:

|             Address Range | Description                     |
| ------------------------: | ------------------------------- |
| `0x00000000`–`0xFFFFFF00` | Regular program and data memory |
| `0xFFFFFF00`–`0xFFFFFFFF` | Memory-mapped I/O registers     |

Typical device mappings:

|         Address | Register        | Access | Description                          |
| --------------: | --------------- | :----: | ------------------------------------ |
|  `0xFFFFFF00`   | Terminal output |  Write | Character to print                   |
|  `0xFFFFFF04`   | Terminal input  |  Read  | Last character typed                 |
|  `0xFFFFFF10`   | Timer config    |   R/W  | Sets timer interval and starts timer |

